// Sources:
// https://www.lysator.liu.se/c/ANSI-C-grammar-y.html
// https://github.com/ranveeraggarwal/simple-c-like-compiler/blob/master/parser/grammar
use std::str::FromStr;
use crate::ast::*;
grammar;

//--------MODULE------------
pub module: Module = {
    function_declaration => {
        Module { functions: vec![<>] }
    },
	<mut m: module> <f: function_declaration> => {
        m.functions.push(f);
        m
    }
};

//--------FUNCTIONS------------
function_declaration: Box<FunctionDeclaration> = {
	<k: type_specifier> <i: identifier> "(" <p: Comma<parameter>?> ")" <s: compound_statement> => Box::new(
        FunctionDeclaration {
            ret: k,
            name: i.name,
            params: p.unwrap_or_else(|| Vec::new()),
            statement: s,
        }
    )
};

parameter: Parameter = {
    <k: type_specifier> <i: identifier> => {
        Parameter {
            kind: k,
            name: i.name
        }
    }
};

//--------EXPRESSIONS------------
expression: Box<Expr> = {
    <l: unary_expression> <o: AssignOp> <r: expression> => {
        Box::new(Expr::Binary(
            BinaryExpr {
                binary_op: o,
                left: l,
                right: r,
                kind: None
            }
        ))
    },
    or_expression
};
AssignOp: BinaryOp = {
    "+=" => BinaryOp::Peq,
    "-=" => BinaryOp::Seq,
    "*=" => BinaryOp::Teq,
    "/=" => BinaryOp::Deq,
    "="  => BinaryOp::Assign,
}

or_expression = Tier<OrOp, and_expression>;
OrOp: BinaryOp = {"||" => BinaryOp::Or};

and_expression = Tier<AndOp, eq_expression>;
AndOp: BinaryOp = {"&&" => BinaryOp::And};

eq_expression = Tier<EqOp, rel_expression>;
EqOp: BinaryOp = {
    "==" => BinaryOp::Eq,
    "!=" => BinaryOp::Neq
};

rel_expression = Tier<RelOp, add_expression>;
RelOp: BinaryOp = {
    ">"  => BinaryOp::Gt,
    "<"  => BinaryOp::Lt,
    ">=" => BinaryOp::Geq,
    "<=" => BinaryOp::Leq
};

add_expression = Tier<AddOp, mul_expression>;
AddOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub
};

mul_expression = Tier<MulOp, unary_expression>;
MulOp: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div
};

unary_expression: Box<Expr> = {
    postfix_expression,
    <u: UnaryOp> <p: postfix_expression> => {
        Box::new(Expr::Unary(
            UnaryExpr {
                unary_op: u,
                expr:     p,
                kind:     None
            }
        ))
    }
};
UnaryOp: UnaryOp = {
    "*" => UnaryOp::Star,
    "!" => UnaryOp::Not,
    "-" => UnaryOp::Neg,
    "&" => UnaryOp::Address
};

// TODO: This doesn't support multi-dimensional arrays.
postfix_expression: Box<Expr> = {
	identifier => Box::new(Expr::Identifier(<>)),
    integer => Box::new(Expr::Integer(<>)),
    float => Box::new(Expr::Float(<>)),
	<i: identifier> "[" <e: expression> "]" => {
        Box::new(Expr::Access(
            AccessExpr { name: i.name, offset: e, kind: None }
        ))
    },
	<i: identifier> "(" <c: Comma<expression>?> ")" => {
        match c {
            None => Box::new(Expr::Function(
                FunctionCall { name: i.name, args: Vec::new(), kind: None, id: 0 }
            )),
            Some(v) => Box::new(Expr::Function(
                FunctionCall { name: i.name, args: v, kind: None, id: 0 }
            )),
        }
    },
    "(" <expression> ")"
};

//--------STATEMENTS------------
statement_list: Vec<Box<Statement>> = {
	statement => vec![<>],
	<mut v: statement_list> <s: statement> => {
        v.push(s);
        v
    }
};

statement: Box<Statement> = {
	compound_statement,
    declare_statement,
	expression_statement,
	selection_statement,
	iteration_statement,
	jump_statement
};

compound_statement: Box<Statement> = {
	"{" <s: statement_list?> "}" => {
        match s {
            None => Box::new(Statement::Compound(
                CompoundStatement { stmts: Vec::new()}
            )),
            Some(l) => Box::new(Statement::Compound(
                CompoundStatement { stmts: l}
            ))
        }
    }
};

declare_statement: Box<Statement> = {
    <k: type_specifier> <i: identifier> ";" => {
        Box::new(Statement::Declare(
            DeclareStatement { kind: k, name: i.name, val: None }
        ))
    },
    <k: type_specifier> <i: identifier> "=" <e: expression> ";" => {
        Box::new(Statement::Declare(
            DeclareStatement { kind: k, name: i.name, val: Some(e) }
        ))
    }
};

expression_statement: Box<Statement> = {
	<expression?> ";" => Box::new(Statement::Expr(
        ExprStatement { expr: <> }
    ))
};

// TODO: allow non-bracketed else?
selection_statement: Box<Statement> = {
    "if" "(" <e: expression> ")" <s1: statement> => Box::new(
        Statement::If( IfStatement {
            condition: e,
            true_stmt: s1,
            false_stmt: None
        })
    ),
    "if" "(" <e: expression> ")" <s1: compound_statement>
    "else" <s2: compound_statement>  => Box::new(
        Statement::If( IfStatement {
            condition: e,
            true_stmt: s1,
            false_stmt: Some(s2)
        })
    )
};

iteration_statement: Box<Statement> = {
	"while" "(" <e: expression> ")" <s: statement> => Box::new(
        Statement::While( WhileStatement {
            condition: e,
            stmt: s
        })
    ),
	"for" "(" <e1: expression?> ";" <e2: expression?> ";" <e3: expression?> ")" <s: statement> => Box::new(
        Statement::For( ForStatement { 
            init: e1,
            each: e2,
            end:  e3,
            stmt: s
        })
    )
};

jump_statement: Box<Statement> = {
	"continue" ";" => Box::new(Statement::Jump(
        JumpStatement { 
            jump_type: JumpOp::Continue,
            expr: None
        }
    )),
    "break" ";" => Box::new(Statement::Jump(
        JumpStatement { 
            jump_type: JumpOp::Break,
            expr: None
        }
    )),
    "return" <expression?> ";" => Box::new(Statement::Jump(
        JumpStatement { 
            jump_type: JumpOp::Return,
            expr: <>
        }
    ))
};

//--------TYPES------------
type_specifier: Kind = {
    <t: type_primitive> <p: pointer?> => {
        match p {
            None    => Kind { indir: 0, prim: t },
            Some(c) => Kind { indir: c, prim: t }
        }
        
    }
};

type_primitive: Primitive = {
    "void"  => Primitive::Void,
    "int"   => Primitive::Integer,
    "float" => Primitive::Float
};

pointer: u32 = {
    "*" => 1,
    <pointer> "*" => <> + 1
};

identifier: Identifier = {
    r"[a-zA-Z][a-zA-Z0-9]*" => {
        Identifier {
            name: <>.to_string(),
            kind: None,
            id: 0
        }
    }
};

integer: i32 = {
    r"\-?[0-9]*" => i32::from_str(<>).unwrap()
};

float: f32 = {
    r"\-?[0-9]+\.[0-9]*" => f32::from_str(<>).unwrap()
};

//--------MACROS------------
Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T> => { // (2)
        v.push(e);
        v
    }
};

Tier<Op, NextTier>: Box<Expr> = {
    <l: Tier<Op, NextTier>> <o: Op> <r: NextTier> => {
        Box::new(Expr::Binary(
            BinaryExpr {
                binary_op: o,
                left: l,
                right: r,
                kind: None
            }
        ))
    },
    NextTier
};

match {
    r"\s*" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
} else {
    _
}